diff --git a/webrtc/base/physicalsocketserver.cc b/webrtc/base/physicalsocketserver.cc
index 8e57d3b..cb00074 100644
--- a/webrtc/base/physicalsocketserver.cc
+++ b/webrtc/base/physicalsocketserver.cc
@@ -189,7 +189,7 @@ SocketAddress PhysicalSocket::GetRemoteAddress() const {
 }
 
 int PhysicalSocket::Bind(const SocketAddress& bind_addr) {
-  SocketAddress copied_bind_addr = bind_addr;
+  /*SocketAddress copied_bind_addr = bind_addr;
   // If a network binder is available, use it to bind a socket to an interface
   // instead of bind(), since this is more reliable on an OS with a weak host
   // model.
@@ -222,9 +222,9 @@ int PhysicalSocket::Bind(const SocketAddress& bind_addr) {
         return -1;
       }
     }
-  }
+  }*/
   sockaddr_storage addr_storage;
-  size_t len = copied_bind_addr.ToSockAddrStorage(&addr_storage);
+  size_t len = bind_addr.ToSockAddrStorage(&addr_storage);//copied_bind_addr.ToSockAddrStorage(&addr_storage);
   sockaddr* addr = reinterpret_cast<sockaddr*>(&addr_storage);
   int err = ::bind(s_, addr, static_cast<int>(len));
   UpdateLastError();
@@ -234,6 +234,16 @@ int PhysicalSocket::Bind(const SocketAddress& bind_addr) {
     dbg_addr_.append(GetLocalAddress().ToString());
   }
 #endif
+
+  //old version
+  if(ss_->network_binder()) {
+    NetworkBindingResult result = ss_->network_binder()->BindSocketToNetwork(s_, bind_addr.ipaddr());
+    if (result != NetworkBindingResult::SUCCESS) {
+      LOG(LS_INFO) << "Binding socket to network address "
+                   << bind_addr.ipaddr().ToString() << "result " << static_cast<int>(result);
+    }
+  }
+
   return err;
 }
 
diff --git a/webrtc/media/engine/internalencoderfactory.cc b/webrtc/media/engine/internalencoderfactory.cc
index a8d4f2d..3470546 100644
--- a/webrtc/media/engine/internalencoderfactory.cc
+++ b/webrtc/media/engine/internalencoderfactory.cc
@@ -34,9 +34,6 @@ bool IsFlexfecAdvertisedFieldTrialEnabled() {
 }  // namespace
 
 InternalEncoderFactory::InternalEncoderFactory() {
-  supported_codecs_.push_back(cricket::VideoCodec(kVp8CodecName));
-  if (webrtc::VP9Encoder::IsSupported())
-    supported_codecs_.push_back(cricket::VideoCodec(kVp9CodecName));
   if (webrtc::H264Encoder::IsSupported()) {
     cricket::VideoCodec codec(kH264CodecName);
     // TODO(magjed): Move setting these parameters into webrtc::H264Encoder
@@ -46,6 +43,9 @@ InternalEncoderFactory::InternalEncoderFactory() {
     codec.SetParam(kH264FmtpLevelAsymmetryAllowed, "1");
     supported_codecs_.push_back(std::move(codec));
   }
+  supported_codecs_.push_back(cricket::VideoCodec(kVp8CodecName));
+  if (webrtc::VP9Encoder::IsSupported())
+    supported_codecs_.push_back(cricket::VideoCodec(kVp9CodecName));
 
   supported_codecs_.push_back(cricket::VideoCodec(kRedCodecName));
   supported_codecs_.push_back(cricket::VideoCodec(kUlpfecCodecName));
diff --git a/webrtc/pc/webrtcsession.cc b/webrtc/pc/webrtcsession.cc
index cc424b2..c37ecbb 100644
--- a/webrtc/pc/webrtcsession.cc
+++ b/webrtc/pc/webrtcsession.cc
@@ -37,7 +37,7 @@
 #include "webrtc/pc/channelmanager.h"
 #include "webrtc/pc/mediasession.h"
 #include "webrtc/pc/sctputils.h"
-#include "webrtc/pc/webrtcsessiondescriptionfactory.h"
+#include "webrtc/pc/webrtcsessiondescriptionfactory.h"  
 
 #ifdef HAVE_QUIC
 #include "webrtc/p2p/quic/quictransportchannel.h"
@@ -1621,8 +1621,7 @@ bool WebRtcSession::UseCandidate(const IceCandidateInterface* candidate) {
   candidates.push_back(candidate->candidate());
   // Invoking BaseSession method to handle remote candidates.
   std::string error;
-  if (transport_controller_->AddRemoteCandidates(content.name, candidates,
-                                                 &error)) {
+  if (transport_controller_->AddRemoteCandidates(content.name, candidates, &error)) {
     // Candidates successfully submitted for checking.
     if (ice_connection_state_ == PeerConnectionInterface::kIceConnectionNew ||
         ice_connection_state_ ==
diff --git a/webrtc/sdk/android/api/org/webrtc/MediaCodecVideoDecoder.java b/webrtc/sdk/android/api/org/webrtc/MediaCodecVideoDecoder.java
index 4ba6b72..dbed743 100644
--- a/webrtc/sdk/android/api/org/webrtc/MediaCodecVideoDecoder.java
+++ b/webrtc/sdk/android/api/org/webrtc/MediaCodecVideoDecoder.java
@@ -80,7 +80,7 @@ public class MediaCodecVideoDecoder {
   private static final String[] supportedVp9HwCodecPrefixes = {"OMX.qcom.", "OMX.Exynos."};
   // List of supported HW H.264 decoders.
   private static final String[] supportedH264HwCodecPrefixes = {
-      "OMX.qcom.", "OMX.Intel.", "OMX.Exynos."};
+      "OMX.qcom.", "OMX.Intel.", "OMX.Exynos.", "OMX.IMG.", "OMX.MTK.", "OMX.Nvidia.", "OMX.TI.", "OMX.rk.", "OMX.amlogic.", "OMX.MARVELL.", "OMX.k3.", "OMX.SEC."};
   // List of supported HW H.264 high profile decoders.
   private static final String[] supportedH264HighProfileHwCodecPrefixes = {"OMX.qcom."};
 
@@ -196,6 +196,7 @@ public class MediaCodecVideoDecoder {
       MediaCodecInfo info = null;
       try {
         info = MediaCodecList.getCodecInfoAt(i);
+	Logging.d(TAG, "All Video Decoders MediaCodecList: " + info.getName());
       } catch (IllegalArgumentException e) {
         Logging.e(TAG, "Cannot retrieve decoder codec info", e);
       }
diff --git a/webrtc/sdk/android/api/org/webrtc/MediaCodecVideoEncoder.java b/webrtc/sdk/android/api/org/webrtc/MediaCodecVideoEncoder.java
index b726860..32298c2 100644
--- a/webrtc/sdk/android/api/org/webrtc/MediaCodecVideoEncoder.java
+++ b/webrtc/sdk/android/api/org/webrtc/MediaCodecVideoEncoder.java
@@ -137,10 +137,28 @@ public class MediaCodecVideoEncoder {
   // List of supported HW H.264 encoders.
   private static final MediaCodecProperties qcomH264HwProperties = new MediaCodecProperties(
       "OMX.qcom.", Build.VERSION_CODES.KITKAT, BitrateAdjustmentType.NO_ADJUSTMENT);
+  private static final MediaCodecProperties hisiH264HwProperties = new MediaCodecProperties(
+      "OMX.IMG.", Build.VERSION_CODES.KITKAT, BitrateAdjustmentType.NO_ADJUSTMENT);
+  private static final MediaCodecProperties k3H264HwProperties = new MediaCodecProperties(
+      "OMX.k3.", Build.VERSION_CODES.KITKAT, BitrateAdjustmentType.NO_ADJUSTMENT);
+  private static final MediaCodecProperties MTKH264HwProperties = new MediaCodecProperties(
+      "OMX.MTK.", Build.VERSION_CODES.KITKAT, BitrateAdjustmentType.NO_ADJUSTMENT);
   private static final MediaCodecProperties exynosH264HwProperties = new MediaCodecProperties(
       "OMX.Exynos.", Build.VERSION_CODES.LOLLIPOP, BitrateAdjustmentType.FRAMERATE_ADJUSTMENT);
+  private static final MediaCodecProperties secH264HwProperties = new MediaCodecProperties(
+      "OMX.SEC.", Build.VERSION_CODES.LOLLIPOP, BitrateAdjustmentType.FRAMERATE_ADJUSTMENT);
+  private static final MediaCodecProperties NvidiaH264HwProperties = new MediaCodecProperties(
+      "OMX.Nvidia.", Build.VERSION_CODES.KITKAT, BitrateAdjustmentType.NO_ADJUSTMENT);
+  private static final MediaCodecProperties TIH264HwProperties = new MediaCodecProperties(
+      "OMX.TI.", Build.VERSION_CODES.KITKAT, BitrateAdjustmentType.NO_ADJUSTMENT);
+  private static final MediaCodecProperties rkH264HwProperties = new MediaCodecProperties(
+      "OMX.rk.", Build.VERSION_CODES.KITKAT, BitrateAdjustmentType.NO_ADJUSTMENT);
+  private static final MediaCodecProperties amlogicH264HwProperties = new MediaCodecProperties(
+      "OMX.amlogic.", Build.VERSION_CODES.KITKAT, BitrateAdjustmentType.NO_ADJUSTMENT);
+  private static final MediaCodecProperties MARVELLH264HwProperties = new MediaCodecProperties(
+      "OMX.MARVELL.", Build.VERSION_CODES.KITKAT, BitrateAdjustmentType.NO_ADJUSTMENT);
   private static final MediaCodecProperties[] h264HwList =
-      new MediaCodecProperties[] {qcomH264HwProperties, exynosH264HwProperties};
+      new MediaCodecProperties[] {qcomH264HwProperties, exynosH264HwProperties, secH264HwProperties, hisiH264HwProperties, k3H264HwProperties, MTKH264HwProperties, NvidiaH264HwProperties, TIH264HwProperties, rkH264HwProperties, amlogicH264HwProperties, MARVELLH264HwProperties};
 
   // List of devices with poor H.264 encoder quality.
   // HW H.264 encoder on below devices has poor bitrate control - actual
@@ -282,6 +300,7 @@ public class MediaCodecVideoEncoder {
       MediaCodecInfo info = null;
       try {
         info = MediaCodecList.getCodecInfoAt(i);
+	Logging.d(TAG, "All Video Encoders MediaCodecList: " + info.getName());
       } catch (IllegalArgumentException e) {
         Logging.e(TAG, "Cannot retrieve encoder codec info", e);
       }
diff --git a/webrtc/webrtc.gni b/webrtc/webrtc.gni
index 5e1c12d..0dd24e4 100644
--- a/webrtc/webrtc.gni
+++ b/webrtc/webrtc.gni
@@ -138,7 +138,8 @@ declare_args() {
   # also: |rtc_initialize_ffmpeg|.
   # CHECK THE OPENH264, FFMPEG AND H.264 LICENSES/PATENTS BEFORE BUILDING.
   # http://www.openh264.org, https://www.ffmpeg.org/
-  rtc_use_h264 = proprietary_codecs && !is_android && !is_ios
+  rtc_use_h264 = true
+  #proprietary_codecs && !is_android && !is_ios
 
   # Determines whether QUIC code will be built.
   rtc_use_quic = false
@@ -156,7 +157,8 @@ declare_args() {
   # only be initialized once. Projects that initialize FFmpeg externally, such
   # as Chromium, must turn this flag off so that WebRTC does not also
   # initialize.
-  rtc_initialize_ffmpeg = !build_with_chromium
+  rtc_initialize_ffmpeg = true
+  #!build_with_chromium
 
   # Build sources requiring GTK. NOTICE: This is not present in Chrome OS
   # build environments, even if available for Chromium builds.
